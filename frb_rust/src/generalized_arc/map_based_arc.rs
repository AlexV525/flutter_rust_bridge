use crate::generalized_arc::base_arc::BaseArc;
use parking_lot::RwLock;
use std::collections::HashMap;
use std::marker::PhantomData;
use std::sync::Arc;

#[derive(Debug)]
pub struct MapBasedArc<T: ?Sized> {
    object_id: ObjectId,
    _phantom: PhantomData<T>,
}

impl<T: ?Sized> AsRef<T> for MapBasedArc<T> {
    fn as_ref(&self) -> &T {
        todo!()
    }
}

impl<T: ?Sized + 'static> BaseArc<T> for MapBasedArc<T> {
    fn new(value: T) -> Self
    where
        T: Sized,
    {
        let mut pool = Self::get_pool().write();

        let object_id = pool.next_id;
        TODO_mod;
        pool.next_id += 1;

        pool.map.insert(
            object_id,
            MapBasedArcPoolValue {
                ref_count: 1,
                value: Arc::new(value),
            },
        );

        Self {
            object_id,
            _phantom: PhantomData,
        }
    }

    fn try_unwrap(self) -> Result<T, Self>
    where
        T: Sized,
    {
        todo!()
    }

    fn into_inner(self) -> Option<T>
    where
        T: Sized,
    {
        todo!()
    }

    unsafe fn from_raw(raw: usize) -> Self
    where
        T: Sized,
    {
        todo!()
    }

    fn into_raw(self) -> usize {
        todo!()
    }
}

impl<T: ?Sized> Clone for MapBasedArc<T> {
    fn clone(&self) -> Self {
        Self::increment_strong_count(self.object_id);

        Self {
            object_id: self.object_id,
            _phantom: PhantomData,
        }
    }
}

impl<T: ?Sized + 'static> MapBasedArc<T> {
    pub(crate) fn increment_strong_count(raw: usize) {
        let map = &mut Self::get_pool().write().map;
        map.get_mut(&raw).unwrap().ref_count += 1;
    }

    pub(crate) fn decrement_strong_count(raw: usize) {
        let mut map = &mut Self::get_pool().write().map;
        let value = map.get_mut(&raw).unwrap();
        value.ref_count -= 1;

        if value.ref_count == 0 {
            map.remove(&raw);
        }
    }
}

impl<T: ?Sized> MapBasedArc<T> {
    fn get_pool() -> &'static MapBasedArcPool<T> {
        todo!() // TODO this should be generated by macro
    }
}

type ObjectId = usize;

type MapBasedArcPool<T: ?Sized> = RwLock<MapBasedArcPoolInner<T>>;

struct MapBasedArcPoolInner<T: ?Sized> {
    map: HashMap<ObjectId, MapBasedArcPoolValue<T>>,
    next_id: ObjectId,
}

struct MapBasedArcPoolValue<T: ?Sized> {
    ref_count: i32,
    value: Arc<T>,
}
